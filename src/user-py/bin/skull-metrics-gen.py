#!/usr/bin/env python3

# This is skull metrics generator and used only for the skull engine itself.
# It will generate the python source files

import sys
import os
import getopt
import string
import pprint
import yaml

# global variables
yaml_obj = None
config_name = ""
source_name = ""

METRICS_TYPE = ["static", "dynamic"]

####################### STATIC TEMPALTES #########################
########################## Source Part ###########################
SOURCE_CONTENT_START = "\
# Automatically generated by skull-metrics-gen.py\n\
\n"

BASE_CLASSES = "\
\n\
############################## Internal Classes ################################\n\
import skull_capi as capi\n\
\n\
class _MetricsBase(object):\n\
    def __init__(self):\n\
        return\n\
\n\
    def get(self, name):\n\
        v = capi.metrics_get(name)\n\
        if v is None:\n\
            return 0.0\n\
        else:\n\
            return v\n\
\n\
    def inc(self, name, value):\n\
        capi.metrics_inc(name, value)\n\
\n\
class _Metrics(_MetricsBase):\n\
    PREFIX = 'skull.user.s'\n\
\n\
    def __init__(self, top_name, name):\n\
        self._seq = (self.PREFIX, top_name, name)\n\
        self._combined_name = '.'.join(self._seq)\n\
        super(_Metrics, self).__init__()\n\
\n\
    def get(self):\n\
        return super(_Metrics, self).get(self._combined_name)\n\
\n\
    def inc(self, value):\n\
        super(_Metrics, self).inc(self._combined_name, value)\n\
\n\
class _MetricsDynamic(_MetricsBase):\n\
    PREFIX = 'skull.user.d'\n\
\n\
    def __init__(self, top_name, name, dynamic_name):\n\
        self._combined_name = '{}.{}.{{{}}}.{}'.format(self.PREFIX, top_name, dynamic_name, name)\n\
        super(_MetricsDynamic, self).__init__()\n\
\n\
    def get(self):\n\
        return super(_MetricsDynamic, self).get(self._combined_name)\n\
\n\
    def inc(self, value):\n\
        super(_MetricsDynamic, self).inc(self._combined_name, value)\n\
\n\
"

############################## Internal APIs ############################
def load_yaml_config():
    global yaml_obj
    global config_name

    yaml_file = open(config_name, 'r')
    yaml_obj = yaml.load(yaml_file, Loader=yaml.FullLoader)

def gen_py_header_metrics(scope_name, metrics_obj):
    global METRICS_TYPE

    if not metrics_obj.get("type"):
        print ("Fatal: don't find 'type' field in the config, please check it again")
        sys.exit(1)

    type = metrics_obj['type']
    if type not in METRICS_TYPE:
        print ("Fatal: 'type' field must be 'static' or 'dynamic', please check it again")
        sys.exit(1)

    if not metrics_obj.get("metrics"):
        print ("Fatal: don't find 'metrics' field in the config, please check it again")
        sys.exit(1)

    metrics_map = metrics_obj['metrics']

    # assemble class titles
    content = "# ==========================================================\n"
    content += "class " + scope_name + "():\n"

    if type == "static":
        content += "    def __init__(self):\n"
    else:
        content += "    def __init__(self, dynamic_name):\n"

    # assemble class members (metrics)
    for name in metrics_map:
        items = metrics_map[name]

        desc = items['desc']

        content += "        # " + desc + "\n"

        if type == "static":
            content += "        self." + name + " = _Metrics('%s', '%s')\n" % (scope_name, name)
        else:
            content += "        self." + name + " = _MetricsDynamic('%s', '%s', dynamic_name)\n" % (scope_name, name)

    # assemble tailer
    content += "\n"

    return content

def generate_py_source():
    source_file = open(source_name, 'w')
    content = ""

    # generate header
    content += SOURCE_CONTENT_START

    # generate body
    for scope_name in yaml_obj:
        content += gen_py_header_metrics(scope_name, yaml_obj[scope_name])

    # generate tailer
    content += BASE_CLASSES

    # write and close the source file
    source_file.write(content)
    source_file.close()

def process_core():
    generate_py_source()

def usage():
    print ("usage: skull-metrics-gen.py -c config -o source_file")

if __name__ == "__main__":
    if len(sys.argv) == 1:
        usage()
        sys.exit(1)

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'c:o:')

        for op, value in opts:
            if op == "-c":
                config_name = value
                load_yaml_config()
            if op == "-o":
                source_name = value

        # Now run the process func according the mode
        process_core()

    except Exception as e:
        print ("Fatal: " + str(e))
        usage()
        raise
