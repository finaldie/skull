#!/usr/bin/env python3

# This is skull metrics generator and which is used for the skull engine itself.
# It will generate a C++ header file

import sys
import os
import getopt
import string
import pprint
import yaml

# global variables
yaml_obj = None
config_name = ""
source_name = ""

METRICS_TYPE = ["static", "dynamic"]

####################### STATIC TEMPALTES #########################
########################## Source Part ###########################
HEADER_CONTENT_START = "\
#ifndef SKULLCPP_USER_METRICS_H\n\
#define SKULLCPP_USER_METRICS_H\n\
\n\
// Automatically generated by skull-metrics-gen.py\n\
\n\
#include <string>\n\
#include <skullcpp/metrics_utils.h>\n\
\n\
namespace skullcpp {\n\
namespace metrics {\n\
\n"

HEADER_CONTENT_END = "\
\n\
} // End of namespace 'metrics'\n\
} // End of namespace 'skullcpp'\n\
\n\
#endif\n\
"

############################## Internal APIs ############################
def load_yaml_config():
    global yaml_obj
    global config_name

    yaml_file = open(config_name, 'r')
    yaml_obj = yaml.load(yaml_file, Loader=yaml.FullLoader)

def gen_cpp_header_metrics(class_name, metrics_obj):
    global METRICS_TYPE

    if not metrics_obj.get("type"):
        print ("Fatal: don't find 'type' field in the config, please check it again")
        sys.exit(1)

    type = metrics_obj['type']
    if type not in METRICS_TYPE:
        print ("Fatal: 'type' field must be 'static' or 'dynamic', please check it again")
        sys.exit(1)

    if not metrics_obj.get("metrics"):
        print ("Fatal: don't find 'metrics' field in the config, please check it again")
        sys.exit(1)

    metrics_map = metrics_obj['metrics']

    # assemble class titles
    content = "// ==========================================================\n"
    content += "class {} {{\n".format(class_name)
    content += "public:\n"
    content += "    ~{}() {{}}\n".format(class_name)

    # assemble metrics
    if type == "static":
        content += "public:\n"

        # declare metrics obj
        for name in metrics_map:
            items = metrics_map[name]
            desc = items['desc']

            content += "    // {}\n".format(desc)
            content += "    Metrics {};\n\n".format(name)

        # assemble constructor
        content += "public:\n"
        content += "    {}() {{\n".format(class_name)

        for name in metrics_map:
            content += "        this->{} = Metrics(\"{}\", \"{}\");\n".format(name, class_name, name)
    else:
        content += "private:\n"
        content += "    std::string dynamicName_;\n"
        content += "public:\n"

        # declare metrics obj
        for name in metrics_map:
            items = metrics_map[name]
            desc = items['desc']

            content += "    // {}\n".format(desc)
            content += "    MetricsDynamic {};\n\n".format(name)

        # assemble constructor
        content += "public:\n"
        content += "    {}(const std::string& dynamicName) : dynamicName_(dynamicName) {{\n".format(class_name)

        for name in metrics_map:
            content += "        this->{} = MetricsDynamic(\"{}\", \"{}\", this->dynamicName_);\n".format(name, class_name, name)

    # assemble tailer
    content += "    }\n"
    content += "};\n"

    return content

def generate_cpp_header():
    source_file = open(source_name, 'w')
    content = ""

    # generate header
    content += HEADER_CONTENT_START

    # generate body
    for scope_name in yaml_obj:
        content += gen_cpp_header_metrics(scope_name, yaml_obj[scope_name])

    # generate tailer
    content += HEADER_CONTENT_END

    # write and close the source file
    source_file.write(content)
    source_file.close()

def process_core():
    generate_cpp_header()

def usage():
    print ("usage: skull-metrics-gen.py -c config -o source_file")

if __name__ == "__main__":
    if len(sys.argv) == 1:
        usage()
        sys.exit(1)

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'c:o:')

        for op, value in opts:
            if op == "-c":
                config_name = value
                load_yaml_config()
            if op == "-o":
                source_name = value

        # Now run the process func according the mode
        process_core()

    except Exception as e:
        print ("Fatal: " + str(e))
        usage()
        raise
